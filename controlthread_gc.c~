/*
    controlthread.c - AR.Drone control thread

    Copyright (C) 2011 Hugo Perquin - http://blog.perquin.com

    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 2 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program; if not, write to the Free Software
    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
    MA 02110-1301 USA.
*/


#include <stdio.h>   /* Standard input/output definitions */
#include <string.h>  /* String function definitions */
#include <unistd.h>  /* UNIX standard function definitions */
#include <fcntl.h>   /* File control definitions */
#include <errno.h>   /* Error number definitions */
#include <termios.h> /* POSIX terminal control definitions */
#include <stdlib.h>  //exit()
#include <pthread.h>
#include <math.h>

#include "util/type.h"
#include "util/util.h"
#include "motorboard/mot.h"
#include "navdata_islab/navdata_islab.h"
#include "udp/udp.h"
#include "pid.h"
#include "controlthread_gc.h"
#include "C_code_geometric_controller/C_code_geometric_controller_2.h"
#include "C_code_geometric_controller/C_code_geometric_controller_initialize.h"

float adj_roll;
float adj_pitch;
float adj_yaw;
float adj_h;
int initial = 0;

pthread_t ctl_thread;

pid_struct pid_roll;
pid_struct pid_pitch;
pid_struct pid_yaw;
pid_struct pid_h;

float throttle;

struct att_struct ahrsdata;

struct setpoint_struct {
  float mode;
  float F1;
  float F2;
  float F3;
  float yawrate;
  float yawratet;

  float pitch_roll_max; //radians     
  float h_max; //cm
  float h_min; //cm
  float throttle_hover; //hover throttle setting
  float throttle_min; //min throttle (while flying)
  float throttle_max; //max throttle (while flying)
} setpoint;

udp_struct udpNavLog;
int logcnt=0;
void navLog_Send();
void *ctl_thread_main(void* data);

int ctl_Init(char *client_addr) 
{
	
	//----- Initialize Attitude -----// 
	int rc;
  	printf("Initialize Attitude.. \n");
	//rc = att_Init(&att);
	//if(rc) return rc;
	if(navdata_init()) printf("navdata initialized\n");
	navdata_flattrim(&ahrsdata);
	//printf("bias_after:%f\t%f\t%f\n",gyros_offset[0],gyros_offset[1],gyros_offset[2]);
        sleep(1);

	//----- Initialize UDP -----//
  	// Udp logger
  	printf("client\n");
  	//udpClient_Init(&udpNavLog, "192.168.43.176", 9930);
	udpClient_Init(&udpNavLog, "192.168.1.2", 9930);
  	//navLog_Send();
  	printf("udpClient_Init\n", rc);
  
	// Start motor thread
	printf("Initialize motor\n");
	rc = mot_Init();
	if(rc) return rc;
  
	// Start ctl thread
	printf("Initialize ctl_thread_main\n"); 
	rc = pthread_create(&ctl_thread, NULL, ctl_thread_main, NULL); 
	if(rc) {
		printf("ctl_Init: Return code from pthread_create(mot_thread) is %d\n", rc);
		return 202;
	}
	else printf("rc = %d\n", rc);

	//----- Initilize GC Controller -----//
	//defaults from AR.Drone app:  pitch,roll max=12deg; yawspeed max=100deg/sec; height limit=on; vertical speed max=700mm/sec; 
	//setpoint.pitch_roll_max=DEG2RAD(10); //degrees     
  	//setpoint.yawsp_max=DEG2RAD(100); //degrees/sec
  	//setpoint.h_max=600; //cm
  	//setpoint.h_min=40; //cm40
           
  	setpoint.throttle_hover=0.1;//0.66
  	setpoint.throttle_min=0.05;//0.5
  	setpoint.throttle_max=0.95; //0.85
	setpoint.F1 = 0.0;
   	setpoint.F2 = 0.0;
  	setpoint.F3 = 0.0;
 	setpoint.yawratet = 0.0;
        
  	throttle=0.000;

	C_code_geometric_controller_initialize();
}

void *ctl_thread_main(void* data)
{
	int cnt;
	int rc;
	//printf("run pthread");
	//navdata_update(&ahrsdata); //get data from thread	
        
        

	while(1) {
		//get sample
		navdata_update(&ahrsdata); //get data from thread		
	/*
			printf("ax:%.2f|",ahrsdata.ax);
			printf("ay:%.2f|",ahrsdata.ay);
			printf("az:%.2f|",ahrsdata.az);
			printf("wx:%.2f|",ahrsdata.wx);
			printf("wy:%.2f|",ahrsdata.wy);
			printf("wz:%.2f|",ahrsdata.wz);
			printf("roll_a:%.1f|",RAD2DEG(ahrsdata.roll_a));
			printf("pithc_a:%.1f|",RAD2DEG(ahrsdata.pitch_a));
			printf("roll_g:%.1f|",RAD2DEG(ahrsdata.roll_w));
			printf("pithc_g:%.1f|",RAD2DEG(ahrsdata.pitch_w));
			printf("yaw_g:%.1f|",RAD2DEG(ahrsdata.yaw_w));
			printf("roll:%.1f|",RAD2DEG(ahrsdata.roll));
			printf("pithc:%.1f|",RAD2DEG(ahrsdata.pitch));
			printf("yaw:%.1f|",RAD2DEG(ahrsdata.yaw));
			printf("dt2:%.6f|",ahrsdata.dt2);
			printf("dt:%.3f\n",ahrsdata.dt);*/	
    /*
    if(initial < 10)
    {
	initial++;
    }
    if(initial == 10)
    {
	setpoint.yawt = ahrsdata.yaw;
	initial = 11;
    }*/	
    float motor[4]; 
    float motor_min = 0.125;
    double input[24];
    double output[3];

    //printf("check = [%.2f,%.2f,%.2f]",check[1],check[2],check[3]);
    //
     
    //printf("check = [%.2f,%.2f,%.2f,%.2f,%.2f,%.2f,%.2f]",output[0],output[1],output[2],output[3],output[4],output[5],output[6]);
    //printf("check = [%.2f,%.2f,%.2f,%.2f] \n",output[0],output[1],output[2],output[3]);
    
    if(setpoint.throttle_hover<=0.02) {
      //setpoint.throttle_hover = setpoint.throttle_hover + setpoint.h;
      //setpoint.h = 0;
      //motors off
      adj_roll = 0;
      adj_pitch = 0;
      adj_h = 0;
      adj_yaw = 0;
      throttle = 0;
      //mot_Run(0.025,0.025,0.025,0.025);
    }else{     
      //flying, calc pid controller corrections
      //printf("errorpitch = %.5f, ", setpoint.pitch-ahrsdata.pitch);
      //printf("errorpitchrate = %.5f, ", ahrsdata.wy+ahrsdata.b_est[1]);
      
      // Manual Control      
      if(setpoint.mode==0) {
        
	input[0] = setpoint.F1; //F1
	input[1] = setpoint.F2; //F2
	input[2] = setpoint.F3; //f3
        input[3] = setpoint.yawratet; //theta
        input[4] = ahrsdata.roll; // roll
	input[5] = ahrsdata.pitch; // pitch
	input[6] = ahrsdata.yaw; // yaw
	input[7] = ahrsdata.wx;
	input[8] = ahrsdata.wy;
	input[9] = ahrsdata.wz;
	input[10] = ahrsdata.dt; //dt
   
	//double kx[9] = {4,0,0,0,4,0,0,0,1};
	//double kv[9] = {5,0,0,0,5,0,0,0,1};
	double kR[9] = {0.35,0,0,0,0.35,0,0,0,0.01}; //0.35
	double kOmega[9] = {0.01,0,0,0,0.01,0,0,0,0.0001}; //0.01
      
	//printf("[roll = %.3f, pitch = %.3f, yaw = %.3f, yawt = %.3f] ",input[18],input[19],input[20],input[3]);
	//printf("[ext = %.3f, eyt= %.3f, ezt = %.3f] ",input[0],input[1],input[2]);
      //printf("mode = %.3f, xt = %.3f, yt = %.3f, ",setpoint.mode,input[0],input[1]);
      //printf("mode = %.3f, xt = %.3f, yt = %.3f, zt = %.3f, ",setpoint.mode,input[0],input[1],input[2],output[3]);
      //printf("mode = %.3f",setpoint.mode);
      //printf("vxt = %.3f",setpoint.vxt);
      //printf("yawt = %.3f",setpoint.yawt);
      //printf("roll = %.3f",ahrsdata.roll);
	C_code_geometric_controller_2(input,kR,kOmega,&output[0],&output[1],&output[2],&output[3]);
      	adj_roll = output[0];
      	adj_pitch = output[1];
      	//adj_yaw = output[2];
        adj_yaw = setpoint.yawratet;
      	//throttle = output[3]/10;
	//need check height velocity hv
        setpoint.throttle_hover = setpoint.throttle_hover + setpoint.F3;
      	throttle = setpoint.throttle_hover; 
      }

      // Trajectory Control by Optitrack
      if(setpoint.mode==1) {
	
	input[0] = setpoint.F1; //F1
	input[1] = setpoint.F2; //F2
	input[2] = setpoint.F3; //f3
        input[3] = setpoint.yawratet; //theta
        input[4] = ahrsdata.roll; // roll
	input[5] = ahrsdata.pitch; // pitch
	input[6] = ahrsdata.yaw; // yaw
	input[7] = ahrsdata.wx;
	input[8] = ahrsdata.wy;
	input[9] = ahrsdata.wz;
	input[10] = ahrsdata.dt; //dt
	
   
	double kx[9] = {0.005,0,0,0,0.005,0,0,0,1.375}; //3 3.873
	double kv[9] = {0.0001,0,0,0,0.0001,0,0,0,0.01}; //0.0001 0.8
	double kR[9] = {0.355,0,0,0,0.355,0,0,0,0.001}; //0.35
	double kOmega[9] = {0.01,0,0,0,0.01,0,0,0,0.00001}; //0.01
      
        //printf("[roll = %.3f, pitch = %.3f, yaw = %.3f, yawt = %.3f] ",input[18],input[19],input[20],input[3]);
        //printf("[ext = %.3f, eyt= %.3f, ezt = %.3f] ",input[0],input[1],input[2]);
        //printf("mode = %.3f, xt = %.3f, yt = %.3f, ",setpoint.mode,input[0],input[1]);
        //printf("mode = %.3f, xt = %.3f, yt = %.3f, zt = %.3f, ",setpoint.mode,input[0],input[1],input[2],output[3]);
        //printf("mode = %.3f",setpoint.mode);
        //printf("vxt = %.3f",setpoint.vxt);
        //printf("yawt = %.3f",setpoint.yawt);
        //printf("roll = %.3f",ahrsdata.roll);
        C_code_geometric_controller_2(input,kR,kOmega,&output[0],&output[1],&output[2],&output[3]);
      	adj_roll = output[0];
      	adj_pitch = output[1];
      	adj_yaw = output[2];
        throttle = output[3]/10;
        //setpoint.throttle_hover = setpoint.throttle_hover + setpoint.evzt;
      	//setpoint.evzt = 0;
      	//throttle = setpoint.throttle_hover; 
      }

      if(throttle < setpoint.throttle_min) throttle = setpoint.throttle_min;
      if(throttle > setpoint.throttle_max) throttle = setpoint.throttle_max;  
      float adj_roll_max =  0.055;
      float adj_roll_min =  -0.055;
      float adj_pitch_max =  0.055;
      float adj_pitch_min =  -0.055;   
      if(adj_roll < adj_roll_min) adj_roll = adj_roll_min;
      if(adj_roll > adj_roll_max) adj_roll = adj_roll_max; 
      if(adj_pitch < adj_pitch_min) adj_pitch = adj_pitch_min;
      if(adj_pitch > adj_pitch_max) adj_pitch = adj_pitch_max; 
    } 
    
    //convert pid adjustments to motor values
    /*
    motor[0] = throttle -adj_pitch;
    motor[1] = throttle -adj_pitch;
    motor[2] = throttle +adj_pitch;
    motor[3] = throttle +adj_pitch;
    */
    /*
    motor[0] = throttle +adj_roll -adj_pitch;
    motor[1] = throttle -adj_roll -adj_pitch;
    motor[2] = throttle -adj_roll +adj_pitch;
    motor[3] = throttle +adj_roll +adj_pitch;*/
    //setpoint.yawratet = 0.0;
    
    motor[0] = throttle +adj_roll -adj_pitch +adj_yaw;
    motor[1] = throttle -adj_roll -adj_pitch -adj_yaw;
    motor[2] = throttle -adj_roll +adj_pitch +adj_yaw;
    motor[3] = throttle +adj_roll +adj_pitch -adj_yaw;

    /*
    motor[0] = output[3] + output[0] - output[1] + output[2];
    motor[1] = output[3] - output[0] - output[1] - output[2];
    motor[2] = output[3] - output[0] + output[1] + output[2];
    motor[3] = output[3] + output[0] + output[1] - output[2];*/
    
    /*
    motor[0] = 0; 
    motor[1] = 0;
    motor[2] = 0;
    motor[3] = 0;*/
	
    /*
    if(motor[0] < motor_min) motor[0] = motor_min;
    if(motor[1] < motor_min) motor[1] = motor_min;
    if(motor[2] < motor_min) motor[2] = motor_min;
    if(motor[3] < motor_min) motor[3] = motor_min;*/

    //printf("throttle = %.3f,adj_roll = %.3f,adj_pitch = %.3f,adj_yaw = %.3f \n", throttle,adj_roll,adj_pitch,adj_yaw);
    //printf("motor:[%.3f - %.3f - %.3f - %.3f]\n ",motor[0],motor[1],motor[2],motor[3]);
    
    //printf("throttle = %.5f, adj_roll = %0.5f, adj_pitch = %0.5f, motor: %.5f,%.5f,%.5f,%.5f \n", throttle,adj_roll,adj_pitch,motor[0],motor[1],motor[2],motor[3]);
    //send to motors
    mot_Run(motor[0],motor[1],motor[2],motor[3]);

    ahrsdata.motor1 = motor[0];
    ahrsdata.motor2 = motor[1];
    ahrsdata.motor3 = motor[2];
    ahrsdata.motor4 = motor[3];
    //blink leds    
    cnt++;
    if((cnt%200)==0) 
      mot_SetLeds(MOT_LEDGREEN,MOT_LEDGREEN,MOT_LEDGREEN,MOT_LEDGREEN);
    else if((cnt%200)==100) 
      mot_SetLeds(0,0,0,0);
        
    //send UDP nav log packet    
    //navLog_Send();
  
		//yield to other threads
		pthread_yield();
	}
}


//logging
void navLog_Send()
{
  char logbuf[512];
  int logbuflen;

  float motval[4];
	mot_GetMot(motval);
  
  logcnt++;//38
  logbuflen=sprintf(logbuf,(char*)" %.3f,%.3f,%.3f,%.3f,%.3f,%.3f,%.3f,%.3f,%.3f,%.3f,%.3f,%.3f,%.3f,%.3f,%.3f,%.3f,%.3f,%.3f,%.3f,%.3f,%.3f,%.3f,%.3f,%.3f,%.3f,%.3f,%.3f,%.3f,%.3f,%.3f,%.3f,%.3f,%.3f,%.3f,%.3f,%.3f,%.3f,%.3f,%.3f,%.3f,%.3f,%.3f "
    //sequence+timestamp
    ,ahrsdata.tm   // navdata timestamp in sec
    ,ahrsdata.tm_pre   
    ,ahrsdata.frame

    ,ahrsdata.pitch_w  //=sum(gx * dt)
    ,ahrsdata.pitch_a  //=pitch(az,ax)
    ,ahrsdata.pitch    //kalman pitch estimate from gy and pitch_a

    //roll estimates in radians, positive is roll right (fly rightward)
    ,ahrsdata.roll_w   //=sum(gy * dt)
    ,ahrsdata.roll_a   //=roll(az,ay)
    ,ahrsdata.roll     //kalman roll estimate from gx and roll_a
  
    //yaw estimate, positive is yaw left
    ,ahrsdata.yaw_w      //=sum(gz * dt)
    ,ahrsdata.yaw_m      //=sum(gz * dt)
    ,ahrsdata.yaw      //=sum(gz * dt)

    ,ahrsdata.dt  // time since last navdata sample in sec
    ,ahrsdata.dt2 // time consumed by the ahrs calculations
    ,ahrsdata.q_est[0]
    ,ahrsdata.q_est[1]
    ,ahrsdata.q_est[2]
    ,ahrsdata.q_est[3]
    ,ahrsdata.b_est[0]
    ,ahrsdata.b_est[1]
    ,ahrsdata.b_est[2]
  
    //copy of physical navdata values
    ,ahrsdata.ts  // navdata timestamp in sec
    ,ahrsdata.hraw    // height above ground in [cm] 
    ,ahrsdata.h_meas// 1=height was measured in this sample, 0=height is copy of prev value

    ,ahrsdata.ax   // acceleration x-axis in [G] front facing up is positive         
    ,ahrsdata.ay   // acceleration y-axis in [G] left facing up is positive                
    ,ahrsdata.az   // acceleration z-axis in [G] top facing up is positive            
    ,ahrsdata.wx   // gyro value x-axis in [rad/sec] right turn, i.e. roll right is positive           
    ,ahrsdata.wy   // gyro value y-axis in [rad/sec] right turn, i.e. pirch down is positive                     
    ,ahrsdata.wz   // gyro value z-axis in [rad/sec] right turn, i.e. yaw left is positive
    ,ahrsdata.magX
    ,ahrsdata.magY 
    ,ahrsdata.magZ
    ,ahrsdata.pressure
    ,ahrsdata.rotX
    ,ahrsdata.rotY
    ,ahrsdata.rotZ
    ,ahrsdata.altd
    ,ahrsdata.motor1
    ,ahrsdata.motor2
    ,ahrsdata.motor3
    ,ahrsdata.motor4
  );    
  udpClient_Send(&udpNavLog,logbuf,logbuflen); 
}

/*
int ctl_FlatTrim()
{
  return att_FlatTrim(&att);
}
*/
void ctl_SetSetpoint(float mode, float F1, float F2, float F3, float yawratet)
{
  //printf("vxt %.3f, vyt %.3f, vzt %.3f, yawratet %.3f \n",vxt,vyt,vzt,yawratet);
  setpoint.mode = mode;
  setpoint.F1 = F1;
  setpoint.F2 = F2;
  setpoint.F3 = F3;
  //setpoint.yawt = setpoint.yawt + yawratet;
  //setpoint.yawratet = yawratet;

  //if(pitch > setpoint.pitch_roll_max) pitch = setpoint.pitch_roll_max;
  //if(pitch < -setpoint.pitch_roll_max) pitch = -setpoint.pitch_roll_max;
  //setpoint.pitch=pitch;
  //if(roll > setpoint.pitch_roll_max) roll = setpoint.pitch_roll_max;
  //if(roll < -setpoint.pitch_roll_max) roll = -setpoint.pitch_roll_max;
  //setpoint.roll=roll;
  //if(yaw > setpoint.yawsp_max) yaw = setpoint.yawsp_max;
  //if(yaw < -setpoint.yawsp_max) yaw = -setpoint.yawsp_max;
  //setpoint.yaw=yaw;
  //if(h > setpoint.h_max) h = setpoint.h_max;
  //if(h <= 0) h = 0;
  //if(h>0 && h < setpoint.h_min) h = setpoint.h_min;
  //if(setpoint.h==0 && h>0) throttle=0.69; //takeoff
  //setpoint.h = h;
}

//void ctl_SetSetpointDiff(float pitch, float roll, float yaw, float h)
//{
  //ctl_SetSetpoint(pitch+setpoint.pitch, setpoint.pitch+pitch, yaw+setpoint.yaw, h+setpoint.h);
//}
/*
void ctl_Close()
{
  mot_Close();
  att_Close();
}
*/
void ctl_SetGas(float gas1)
{
	throttle+=gas1;
}

